//! Firmware generation for QMK keymap.c and vial.json.
//!
//! This module generates QMK C code and Vial JSON configuration
//! from keyboard layouts using the LED index order.

use crate::config::Config;
use crate::models::keyboard_geometry::KeyboardGeometry;
use crate::models::layout::Layout;
use crate::models::visual_layout_mapping::VisualLayoutMapping;
use anyhow::{Context, Result};
use serde_json::json;
use std::fs;

/// Firmware generator for keymap.c and vial.json.
pub struct FirmwareGenerator<'a> {
    layout: &'a Layout,
    geometry: &'a KeyboardGeometry,
    mapping: &'a VisualLayoutMapping,
    config: &'a Config,
}

impl<'a> FirmwareGenerator<'a> {
    /// Creates a new firmware generator.
    #[must_use]
    pub const fn new(
        layout: &'a Layout,
        geometry: &'a KeyboardGeometry,
        mapping: &'a VisualLayoutMapping,
        config: &'a Config,
    ) -> Self {
        Self {
            layout,
            geometry,
            mapping,
            config,
        }
    }

    /// Generates keymap.c and vial.json files.
    ///
    /// Returns paths to the generated files.
    pub fn generate(&self) -> Result<(String, String)> {
        // Generate keymap.c
        let keymap_c = self.generate_keymap_c()?;
        let keymap_path = self.write_keymap_c(&keymap_c)?;

        // Generate vial.json
        let vial_json = self.generate_vial_json()?;
        let vial_path = self.write_vial_json(&vial_json)?;

        Ok((keymap_path, vial_path))
    }

    /// Generates keymap.c C code.
    ///
    /// Creates a QMK keymap file with PROGMEM arrays for each layer.
    /// Keys are ordered by LED index as required by QMK.
    fn generate_keymap_c(&self) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str("// Generated by keyboard_tui\n");
        code.push_str(&format!("// Layout: {}\n", self.layout.metadata.name));
        code.push_str(&format!("// Keyboard: {}\n", self.config.build.keyboard));
        code.push_str(&format!(
            "// Layout Variant: {}\n",
            self.config.build.layout
        ));
        code.push('\n');

        // Includes
        code.push_str("#include QMK_KEYBOARD_H\n\n");

        // Keymap definition
        code.push_str("const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {\n");

        // Generate each layer
        for (layer_idx, layer) in self.layout.layers.iter().enumerate() {
            code.push_str(&format!("    // Layer {}: {}\n", layer_idx, layer.name));
            code.push_str(&format!(
                "    [{}] = {}(",
                layer_idx, self.config.build.layout
            ));

            // Generate keys in LED order
            let keys_by_led = self.generate_layer_keys_by_led(layer)?;

            // Format keys (wrap at reasonable line length)
            let keys_str = keys_by_led.join(", ");
            if keys_str.len() > 80 {
                // Multi-line formatting
                code.push_str("\n        ");
                for (idx, keycode) in keys_by_led.iter().enumerate() {
                    code.push_str(keycode);
                    if idx < keys_by_led.len() - 1 {
                        code.push_str(", ");
                    }
                    // Line wrap every 6 keys
                    if (idx + 1) % 6 == 0 && idx < keys_by_led.len() - 1 {
                        code.push_str("\n        ");
                    }
                }
                code.push_str("\n    ");
            } else {
                // Single line formatting
                code.push_str(&keys_str);
            }

            code.push(')');
            if layer_idx < self.layout.layers.len() - 1 {
                code.push_str(",\n");
            } else {
                code.push('\n');
            }
        }

        code.push_str("};\n");

        Ok(code)
    }

    /// Generates key assignments for a layer ordered by LED index.
    ///
    /// This is the critical transformation: visual position → matrix → LED order.
    fn generate_layer_keys_by_led(
        &self,
        layer: &crate::models::layer::Layer,
    ) -> Result<Vec<String>> {
        let led_count = self.mapping.key_count();
        let mut keys_by_led = vec![String::from("KC_NO"); led_count];

        // Map each key to its LED position
        for key in &layer.keys {
            let visual_pos = key.position;

            // Visual → Matrix
            let matrix_pos = self
                .mapping
                .visual_to_matrix_pos(visual_pos.row, visual_pos.col)
                .with_context(|| {
                    format!(
                        "Failed to map visual position ({}, {}) to matrix",
                        visual_pos.row, visual_pos.col
                    )
                })?;

            // Matrix → LED
            let led_idx = self
                .mapping
                .visual_to_led_index(visual_pos.row, visual_pos.col)
                .with_context(|| {
                    format!(
                        "Failed to map matrix position ({}, {}) to LED index",
                        matrix_pos.0, matrix_pos.1
                    )
                })?;

            // Store keycode at LED position
            keys_by_led[led_idx as usize] = key.keycode.clone();
        }

        Ok(keys_by_led)
    }

    /// Generates vial.json configuration.
    ///
    /// Creates a Vial JSON file with layout definition and metadata.
    fn generate_vial_json(&self) -> Result<String> {
        let vial_config = json!({
            "name": self.layout.metadata.name,
            "vendor_product_id": "0xFEED:0x0000", // Default, should be overridden
            "lighting": "none",
            "matrix": {
                "rows": self.geometry.matrix_rows,
                "cols": self.geometry.matrix_cols
            },
            "layouts": {
                "keymap": self.generate_vial_layout_array()?
            },
            "layers": self.layout.layers.len(),
            "author": self.layout.metadata.author,
            "description": self.layout.metadata.description,
            "tags": self.layout.metadata.tags
        });

        let json_str =
            serde_json::to_string_pretty(&vial_config).context("Failed to serialize vial.json")?;

        Ok(json_str)
    }

    /// Generates the Vial layout array.
    ///
    /// Creates the visual key layout for the Vial UI.
    fn generate_vial_layout_array(&self) -> Result<serde_json::Value> {
        let mut layout_keys = Vec::new();

        // Get all keys from first layer (geometry is same for all layers)
        let first_layer = self
            .layout
            .layers
            .first()
            .context("Layout must have at least one layer")?;

        for key in &first_layer.keys {
            // Get key geometry via LED mapping
            let led_idx = self
                .mapping
                .visual_to_led_index(key.position.row, key.position.col)
                .context("Failed to map key to LED index")?;

            let key_geom = self
                .geometry
                .get_key_by_led(led_idx)
                .context("Failed to get key geometry")?;

            // Create Vial key definition
            // Format: [x, y, width, height, matrix_row, matrix_col]
            layout_keys.push(json!([
                key_geom.visual_x,
                key_geom.visual_y,
                key_geom.width,
                key_geom.height,
                key_geom.matrix_position.0,
                key_geom.matrix_position.1
            ]));
        }

        Ok(json!(layout_keys))
    }

    /// Writes keymap.c to the output directory.
    fn write_keymap_c(&self, content: &str) -> Result<String> {
        let output_dir = self.get_keymap_directory()?;
        let keymap_path = output_dir.join("keymap.c");

        // Atomic write using temp file
        let temp_path = output_dir.join("keymap.c.tmp");
        fs::write(&temp_path, content)
            .with_context(|| format!("Failed to write {}", temp_path.display()))?;

        fs::rename(&temp_path, &keymap_path).with_context(|| {
            format!(
                "Failed to rename {} to {}",
                temp_path.display(),
                keymap_path.display()
            )
        })?;

        Ok(keymap_path.display().to_string())
    }

    /// Writes vial.json to the output directory.
    fn write_vial_json(&self, content: &str) -> Result<String> {
        let output_dir = self.get_keymap_directory()?;
        let vial_path = output_dir.join("vial.json");

        // Atomic write using temp file
        let temp_path = output_dir.join("vial.json.tmp");
        fs::write(&temp_path, content)
            .with_context(|| format!("Failed to write {}", temp_path.display()))?;

        fs::rename(&temp_path, &vial_path).with_context(|| {
            format!(
                "Failed to rename {} to {}",
                temp_path.display(),
                vial_path.display()
            )
        })?;

        Ok(vial_path.display().to_string())
    }

    /// Gets the keymap output directory.
    ///
    /// Creates directory structure if it doesn't exist:
    /// {`qmk_firmware}/keyboards/{keyboard}/keymaps/{keymap`}/
    fn get_keymap_directory(&self) -> Result<std::path::PathBuf> {
        let qmk_path = self
            .config
            .paths
            .qmk_firmware
            .as_ref()
            .context("QMK firmware path not configured")?;

        let keymap_dir = qmk_path
            .join("keyboards")
            .join(&self.config.build.keyboard)
            .join("keymaps")
            .join(&self.config.build.keymap);

        // Create directory if it doesn't exist
        fs::create_dir_all(&keymap_dir)
            .with_context(|| format!("Failed to create directory {}", keymap_dir.display()))?;

        Ok(keymap_dir)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::keyboard_geometry::KeyGeometry;
    use crate::models::layer::{KeyDefinition, Layer, Position};
    use crate::models::RgbColor;
    use std::path::PathBuf;

    fn create_test_setup() -> (Layout, KeyboardGeometry, VisualLayoutMapping, Config) {
        let mut layout = Layout::new("Test").unwrap();
        let mut layer = Layer::new(0, "Base", RgbColor::new(255, 255, 255)).unwrap();
        layer.add_key(KeyDefinition::new(Position::new(0, 0), "KC_A"));
        layer.add_key(KeyDefinition::new(Position::new(0, 1), "KC_B"));
        layout.add_layer(layer).unwrap();

        let mut geometry = KeyboardGeometry::new("test", "LAYOUT", 2, 2);
        geometry.add_key(KeyGeometry::new((0, 0), 0, 0.0, 0.0));
        geometry.add_key(KeyGeometry::new((0, 1), 1, 1.0, 0.0));

        let mapping = VisualLayoutMapping::build(&geometry);

        let mut config = Config::default();
        config.paths.qmk_firmware = Some(PathBuf::from("/tmp/qmk_test"));
        config.build.keyboard = "test".to_string();
        config.build.layout = "LAYOUT".to_string();
        config.build.keymap = "default".to_string();

        (layout, geometry, mapping, config)
    }

    #[test]
    fn test_generate_keymap_c() {
        let (layout, geometry, mapping, config) = create_test_setup();
        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config);

        let keymap_c = generator.generate_keymap_c().unwrap();

        // Verify header
        assert!(keymap_c.contains("// Generated by keyboard_tui"));
        assert!(keymap_c.contains("// Layout: Test"));
        assert!(keymap_c.contains("#include QMK_KEYBOARD_H"));

        // Verify keymap structure
        assert!(keymap_c.contains("const uint16_t PROGMEM keymaps[]"));
        assert!(keymap_c.contains("[0] = LAYOUT("));
        assert!(keymap_c.contains("KC_A"));
        assert!(keymap_c.contains("KC_B"));
    }

    #[test]
    fn test_generate_layer_keys_by_led() {
        let (layout, geometry, mapping, config) = create_test_setup();
        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config);

        let layer = &layout.layers[0];
        let keys_by_led = generator.generate_layer_keys_by_led(layer).unwrap();

        assert_eq!(keys_by_led.len(), 2);
        assert_eq!(keys_by_led[0], "KC_A");
        assert_eq!(keys_by_led[1], "KC_B");
    }

    #[test]
    fn test_generate_vial_json() {
        let (layout, geometry, mapping, config) = create_test_setup();
        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config);

        let vial_json = generator.generate_vial_json().unwrap();

        // Verify JSON structure
        assert!(vial_json.contains(r#""name": "Test""#));
        assert!(vial_json.contains(r#""rows": 2"#));
        assert!(vial_json.contains(r#""cols": 2"#));
        assert!(vial_json.contains(r#""layers": 1"#));
    }

    #[test]
    fn test_generate_vial_layout_array() {
        let (layout, geometry, mapping, config) = create_test_setup();
        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config);

        let layout_array = generator.generate_vial_layout_array().unwrap();
        let layout_vec = layout_array.as_array().unwrap();

        assert_eq!(layout_vec.len(), 2);
        // Verify first key has expected structure [x, y, w, h, row, col]
        let first_key = &layout_vec[0];
        assert!(first_key.is_array());
        assert_eq!(first_key.as_array().unwrap().len(), 6);
    }
}
