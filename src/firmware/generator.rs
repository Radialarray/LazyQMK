//! Firmware generation for QMK keymap.c and config.h.
//!
//! This module generates QMK C code from keyboard layouts using the LED index order.
//! Works with standard QMK firmware (not Vial fork).

// Allow format! appended to String - more readable than write! in code generation
#![allow(clippy::format_push_string)]

use crate::config::Config;
use crate::constants::APP_BINARY_NAME;
use crate::keycode_db::KeycodeDb;
use crate::models::keyboard_geometry::KeyboardGeometry;
use crate::models::layout::Layout;
use crate::models::visual_layout_mapping::VisualLayoutMapping;
use anyhow::{Context, Result};
use std::collections::HashSet;
use std::fs;

// Language-specific keycode headers are now loaded dynamically from KeycodeDb.languages()
// No more hardcoded KEYCODE_PREFIX_HEADERS constant needed!

/// Firmware generator for keymap.c and config.h.
pub struct FirmwareGenerator<'a> {
    layout: &'a Layout,
    geometry: &'a KeyboardGeometry,
    mapping: &'a VisualLayoutMapping,
    config: &'a Config,
    keycode_db: &'a KeycodeDb,
}

impl<'a> FirmwareGenerator<'a> {
    /// Creates a new firmware generator.
    #[must_use]
    pub const fn new(
        layout: &'a Layout,
        geometry: &'a KeyboardGeometry,
        mapping: &'a VisualLayoutMapping,
        config: &'a Config,
        keycode_db: &'a KeycodeDb,
    ) -> Self {
        Self {
            layout,
            geometry,
            mapping,
            config,
            keycode_db,
        }
    }

    /// Generates keymap.c and config.h files.
    ///
    /// Files are written to both:
    /// 1. Timestamped output directory (for archival)
    /// 2. QMK keymap directory (for building)
    ///
    /// Returns paths to the generated files in the timestamped directory:
    /// (keymap_path, config_h_path)
    pub fn generate(&self) -> Result<(String, String)> {
        // Create timestamped output directory
        let timestamp_dir = self.create_timestamped_output_dir()?;

        // Generate config.h (merge with keyboard config if exists)
        let config_h = self.generate_merged_config_h()?;
        let config_h_path = self.write_file_to_both(&timestamp_dir, "config.h", &config_h)?;

        // Generate keymap.c
        let keymap_c = self.generate_keymap_c()?;
        let keymap_path = self.write_file_to_both(&timestamp_dir, "keymap.c", &keymap_c)?;

        Ok((keymap_path, config_h_path))
    }

    /// Generates keymap.c C code.
    ///
    /// Creates a QMK keymap file with PROGMEM arrays for each layer.
    /// Keys are ordered by LED index as required by QMK.
    pub fn generate_keymap_c(&self) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str(&format!("// Generated by {}\n", APP_BINARY_NAME));
        code.push_str(&format!("// Layout: {}\n", self.layout.metadata.name));
        code.push_str(&format!(
            "// Keyboard: {}\n",
            self.layout
                .metadata
                .keyboard
                .as_deref()
                .unwrap_or("unknown")
        ));
        code.push_str(&format!(
            "// Layout Variant: {}\n",
            self.layout
                .metadata
                .layout_variant
                .as_deref()
                .unwrap_or("unknown")
        ));
        code.push('\n');

        // Includes
        code.push_str("#include QMK_KEYBOARD_H\n");

        // Add language-specific keycode headers if needed
        let required_headers = self.detect_required_headers();
        for header in &required_headers {
            code.push_str(&format!("#include \"{}\"\n", header));
        }

        // Tap dance requires process_tap_dance.h definitions
        if !self.layout.tap_dances.is_empty() {
            code.push_str("#include \"process_keycode/process_tap_dance.h\"\n");
        }

        code.push('\n');

        // Add tap dance configuration if any tap dances are defined
        if !self.layout.tap_dances.is_empty() {
            code.push_str("// Tap Dance Configuration\n");
            code.push_str(&self.generate_tap_dance_enum());
            code.push('\n');
            code.push_str(&self.generate_tap_dance_helpers());
            if !self.generate_tap_dance_helpers().is_empty() {
                code.push('\n');
            }
            code.push_str(&self.generate_tap_dance_actions());
            code.push('\n');
        }

        // Keymap definition
        code.push_str("const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {\n");

        // Generate each layer
        for (layer_idx, layer) in self.layout.layers.iter().enumerate() {
            code.push_str(&format!("    // Layer {}: {}\n", layer_idx, layer.name));
            code.push_str(&format!(
                "[{}] = {}(",
                layer_idx,
                self.layout
                    .metadata
                    .layout_variant
                    .as_deref()
                    .unwrap_or("LAYOUT")
            ));

            // Generate keys in layout order (matches info.json layout array)
            let keys_by_layout = self.generate_layer_keys_by_layout(layer)?;

            // Format keys (wrap at reasonable line length)
            let keys_str = keys_by_layout.join(", ");
            if keys_str.len() > 80 {
                // Multi-line formatting
                code.push_str("\n        ");
                for (idx, keycode) in keys_by_layout.iter().enumerate() {
                    code.push_str(keycode);
                    if idx < keys_by_layout.len() - 1 {
                        code.push_str(", ");
                    }
                    // Line wrap every 6 keys
                    if (idx + 1) % 6 == 0 && idx < keys_by_layout.len() - 1 {
                        code.push_str("\n        ");
                    }
                }
                code.push_str("\n    ");
            } else {
                // Single line formatting
                code.push_str(&keys_str);
            }

            code.push(')');
            if layer_idx < self.layout.layers.len() - 1 {
                code.push_str(",\n");
            } else {
                code.push('\n');
            }
        }

        code.push_str("};\n");

        // Add conditional encoder_map (only when ENCODER_MAP_ENABLE is defined)
        code.push('\n');
        code.push_str(&self.generate_conditional_encoder_map()?);

        // Add optional RGB matrix base color table when RGB is present.
        code.push('\n');
        code.push_str(&self.generate_rgb_matrix_color_table()?);

        // Add idle effect state machine code if enabled
        code.push('\n');
        code.push_str(&self.generate_idle_effect_code()?);

        // Add RGB overlay ripple code if enabled
        code.push('\n');
        code.push_str(&self.generate_ripple_overlay_code()?);

        Ok(code)
    }

    /// Scans all keycodes in the layout and returns the set of additional
    /// header files that need to be included for language-specific keycodes.
    ///
    /// This detects keycodes like `DE_Y`, `DE_UDIA` that require language-specific
    /// headers from QMK's keymap_extras directory.
    ///
    /// Language prefix-to-header mappings are loaded dynamically from the KeycodeDb,
    /// supporting all languages defined in the keycode database.
    fn detect_required_headers(&self) -> Vec<String> {
        let mut headers = HashSet::new();

        // Build prefix-to-header mapping from language database
        let languages = self.keycode_db.languages();
        let prefix_headers: Vec<(&str, &str)> = languages
            .iter()
            .map(|lang| (lang.prefix.as_str(), lang.header.as_str()))
            .collect();

        for layer in &self.layout.layers {
            for key in &layer.keys {
                let keycode = &key.keycode;
                for (prefix, header) in &prefix_headers {
                    // Check if keycode starts with prefix (e.g., "DE_Y")
                    // or contains it in parameterized form (e.g., "LT(1, DE_Y)")
                    if keycode.starts_with(prefix) || keycode.contains(prefix) {
                        headers.insert((*header).to_string());
                        break;
                    }
                }
            }
        }

        headers.into_iter().collect()
    }

    /// Generates a conditional `encoder_map` wrapped in #ifdef `ENCODER_MAP_ENABLE`.
    ///
    /// This allows the keymap to work both with and without encoders enabled.
    /// When `ENCODER_MAP_ENABLE` is defined in rules.mk, this `encoder_map` will be included.
    #[allow(clippy::unnecessary_wraps)]
    fn generate_conditional_encoder_map(&self) -> Result<String> {
        let mut code = String::new();

        // Get encoder count from keyboard geometry (0 if not specified)
        let encoder_count = self.geometry.encoder_count as usize;

        code.push_str("#ifdef ENCODER_MAP_ENABLE\n");
        code.push_str("const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {\n");

        // Generate encoder bindings for each layer
        // Default encoder actions cycle through: RGB effect, hue, brightness, saturation
        let default_encoder_bindings = [
            ("RM_NEXT", "RM_PREV"), // Encoder 0: RGB effect
            ("RM_HUEU", "RM_HUED"), // Encoder 1: RGB hue
            ("RM_VALU", "RM_VALD"), // Encoder 2: RGB brightness
            ("RM_SATU", "RM_SATD"), // Encoder 3: RGB saturation
            ("KC_VOLU", "KC_VOLD"), // Encoder 4+: Volume (fallback for extra encoders)
        ];

        for (layer_idx, _layer) in self.layout.layers.iter().enumerate() {
            code.push_str(&format!("    [{layer_idx}] = {{\n"));

            // Generate encoder bindings based on actual encoder count
            for enc_idx in 0..encoder_count {
                let (ccw, cw) = if enc_idx < default_encoder_bindings.len() {
                    default_encoder_bindings[enc_idx]
                } else {
                    // Fallback for any additional encoders beyond our defaults
                    default_encoder_bindings[default_encoder_bindings.len() - 1]
                };
                code.push_str(&format!("        ENCODER_CCW_CW({ccw}, {cw}),\n"));
            }

            code.push_str("    }");

            if layer_idx < self.layout.layers.len() - 1 {
                code.push_str(",\n");
            } else {
                code.push_str(",\n");
            }
        }

        code.push_str("};\n");
        code.push_str("#endif\n");

        Ok(code)
    }

    /// Generates keycodes for a layer ordered by layout index.
    ///
    /// This is the critical transformation: visual position → matrix → layout order.
    /// The layout order matches the info.json layout array, which is what QMK's
    /// LAYOUT macro expects.
    ///
    /// Layer references (e.g., `MO(@uuid)`) are resolved to numeric indices
    /// (e.g., `MO(1)`) for firmware compatibility.
    fn generate_layer_keys_by_layout(
        &self,
        layer: &crate::models::layer::Layer,
    ) -> Result<Vec<String>> {
        let key_count = self.mapping.key_count();
        let mut keys_by_layout = vec![String::from("KC_NO"); key_count];

        // Map each key to its layout position
        for key in &layer.keys {
            let visual_pos = key.position;

            // Visual → Layout index
            let layout_idx = self
                .mapping
                .visual_to_layout_index(visual_pos.row, visual_pos.col)
                .with_context(|| {
                    format!(
                        "Failed to map visual position ({}, {}) to layout index",
                        visual_pos.row, visual_pos.col
                    )
                })?;

            // Resolve layer references in keycode (e.g., MO(@uuid) -> MO(1))
            let resolved_keycode = self.resolve_keycode(&key.keycode);

            // Process tap dance keycodes (e.g., TD(name) -> TD(TD_NAME))
            let processed_keycode = self.process_keycode_for_tap_dance(&resolved_keycode);

            // Store keycode at layout position
            keys_by_layout[layout_idx as usize] = processed_keycode;
        }

        Ok(keys_by_layout)
    }

    /// Resolves a keycode, converting layer references to numeric indices.
    ///
    /// If the keycode contains a layer reference like `MO(@uuid)`, it will be
    /// resolved to the numeric index like `MO(1)`. If resolution fails (e.g.,
    /// the referenced layer no longer exists), the original keycode is returned.
    fn resolve_keycode(&self, keycode: &str) -> String {
        // Try to resolve layer references using the keycode database
        if let Some(resolved) = self.layout.resolve_layer_keycode(keycode, self.keycode_db) {
            resolved
        } else {
            // Not a layer keycode or resolution failed - use as-is
            keycode.to_string()
        }
    }

    /// Generates resolved colors for a layer ordered by LED index.
    ///
    /// Colors use the same visual -> LED mapping for LED-based features
    /// and honor the layout's four-level color priority system and the
    /// `inactive_key_behavior` setting.
    ///
    /// If the layer has `colors_enabled = false`, returns all black (off) colors.
    fn generate_layer_colors_by_led(
        &self,
        layer_idx: usize,
    ) -> Result<Vec<crate::models::RgbColor>> {
        let led_count = self.mapping.key_count();
        let mut colors_by_led = vec![crate::models::RgbColor::default(); led_count];

        let layer = self
            .layout
            .get_layer(layer_idx)
            .with_context(|| format!("Invalid layer index {layer_idx}"))?;

        // If layer colors are disabled for this layer, return all black (LEDs off)
        if !layer.layer_colors_enabled {
            return Ok(vec![crate::models::RgbColor::new(0, 0, 0); led_count]);
        }

        // Map each key's resolved color to its LED position
        // Uses resolve_display_color which considers inactive_key_behavior
        for key in &layer.keys {
            let visual_pos = key.position;

            let led_idx = self
                .mapping
                .visual_to_led_index(visual_pos.row, visual_pos.col)
                .with_context(|| {
                    format!(
                        "Failed to map visual position ({}, {}) to LED index",
                        visual_pos.row, visual_pos.col
                    )
                })?;

            // Use resolve_display_color to respect inactive_key_behavior
            let (color, _is_key_specific) = self.layout.resolve_display_color(layer_idx, key);
            // Apply RGB settings (brightness and master switch)
            let final_color = self.layout.apply_rgb_settings(color);
            colors_by_led[led_idx as usize] = final_color;
        }

        Ok(colors_by_led)
    }

    /// Returns true if the layout uses any custom color semantics.
    ///
    /// This treats the layout as "colored" if:
    /// - Any layer default color differs from the global default (white), or
    /// - Any layer has a category, or
    /// - Any key has a color override or category, or
    /// - The layout defines any categories at all.
    fn layout_has_custom_colors(&self) -> bool {
        if !self.layout.categories.is_empty() {
            return true;
        }

        let default_color = crate::models::RgbColor::default();

        for layer in &self.layout.layers {
            if layer.default_color != default_color {
                return true;
            }

            if layer.category_id.is_some() {
                return true;
            }

            for key in &layer.keys {
                if key.color_override.is_some() || key.category_id.is_some() {
                    return true;
                }
            }
        }

        false
    }

    /// Generates an RGB matrix base color table in C when RGB is present.
    ///
    /// The table layout is:
    /// `const uint8_t PROGMEM layer_base_colors[NUM_LAYERS][RGB_MATRIX_LED_COUNT][3]`.
    fn generate_rgb_matrix_color_table(&self) -> Result<String> {
        // If the keyboard has no RGB matrix (no keys), emit an empty string
        // to avoid unused data in non-RGB builds.
        if !self.geometry.has_rgb_matrix() {
            return Ok(String::new());
        }

        let mut code = String::new();
        let layer_count = self.layout.layers.len();
        let led_count = self.mapping.key_count();

        code.push_str("#ifdef RGB_MATRIX_ENABLE\n");
        code.push_str(&format!(
            "const uint8_t PROGMEM layer_base_colors[{layer_count}][{led_count}][3] = {{\n"
        ));

        for layer_idx in 0..layer_count {
            let colors = self.generate_layer_colors_by_led(layer_idx)?;
            code.push_str("    {\n");

            for (led_idx, color) in colors.iter().enumerate() {
                code.push_str(&format!(
                    "        {{{:3}, {:3}, {:3}}}",
                    color.r, color.g, color.b
                ));

                if led_idx < colors.len() - 1 {
                    code.push(',');
                }

                code.push('\n');
            }

            code.push_str("    }");
            if layer_idx < layer_count - 1 {
                code.push_str(",\n");
            } else {
                code.push('\n');
            }
        }

        code.push_str("};\n");
        code.push_str(&format!(
            "const uint8_t PROGMEM layer_base_colors_layer_count = {layer_count};\n"
        ));
        code.push_str("#endif\n");

        Ok(code)
    }

    /// Gets the keymap output directory.
    ///
    /// Creates directory structure if it doesn't exist:
    /// {`qmk_firmware}/keyboards/{keyboard}/keymaps/{keymap`}/
    ///
    /// The keyboard path may include variant subdirectories (e.g., "`keebart/corne_choc_pro/standard`").
    /// The keymap directory is created under the exact keyboard path used for building.
    fn get_keymap_directory(&self) -> Result<std::path::PathBuf> {
        let qmk_path = self
            .config
            .paths
            .qmk_firmware
            .as_ref()
            .context("QMK firmware path not configured")?;

        // Use the keyboard path from layout metadata (which may include a variant)
        // E.g., "keebart/corne_choc_pro/standard" -> keyboards/keebart/corne_choc_pro/standard/keymaps/{keymap}
        let keyboard = self
            .layout
            .metadata
            .keyboard
            .as_deref()
            .context("Keyboard not set in layout metadata")?;
        let keymap = self
            .layout
            .metadata
            .keymap_name
            .as_deref()
            .context("Keymap name not set in layout metadata")?;

        let keymap_dir = qmk_path
            .join("keyboards")
            .join(keyboard)
            .join("keymaps")
            .join(keymap);

        // Create directory if it doesn't exist
        fs::create_dir_all(&keymap_dir)
            .with_context(|| format!("Failed to create directory {}", keymap_dir.display()))?;

        Ok(keymap_dir)
    }

    /// Creates a timestamped output directory for this build.
    ///
    /// Format: {`output_dir}/{keyboard`}_{keymap}_{`YYYYMMDD_HHMMSS`}/
    fn create_timestamped_output_dir(&self) -> Result<std::path::PathBuf> {
        let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S");

        let keyboard = self
            .layout
            .metadata
            .keyboard
            .as_deref()
            .ok_or_else(|| anyhow::anyhow!("Keyboard not specified in layout metadata"))?;
        let keymap = self
            .layout
            .metadata
            .keymap_name
            .as_deref()
            .ok_or_else(|| anyhow::anyhow!("Keymap name not specified in layout metadata"))?;

        let dir_name = format!("{}_{}_{}", keyboard.replace('/', "_"), keymap, timestamp);

        let output_dir = self.config.build.output_dir.join(dir_name);

        fs::create_dir_all(&output_dir).with_context(|| {
            format!("Failed to create output directory {}", output_dir.display())
        })?;

        Ok(output_dir)
    }

    /// Writes a file to both the timestamped archive and the QMK keymap directory.
    ///
    /// Returns the path in the timestamped directory.
    fn write_file_to_both(
        &self,
        timestamp_dir: &std::path::Path,
        filename: &str,
        content: &str,
    ) -> Result<String> {
        // Write to timestamped archive directory
        let archive_path = timestamp_dir.join(filename);
        fs::write(&archive_path, content)
            .with_context(|| format!("Failed to write {}", archive_path.display()))?;

        // Write to QMK keymap directory
        let keymap_dir = self.get_keymap_directory()?;
        let qmk_path = keymap_dir.join(filename);
        fs::write(&qmk_path, content)
            .with_context(|| format!("Failed to write {}", qmk_path.display()))?;

        Ok(archive_path.display().to_string())
    }

    /// Generates idle effect state machine code if enabled.
    ///
    /// Emits C code to manage idle timeout and transition between ACTIVE, IDLE_EFFECT, and OFF states.
    /// The code tracks activity using timer_read/timer_elapsed and switches RGB effects accordingly.
    #[allow(clippy::unnecessary_wraps)]
    fn generate_idle_effect_code(&self) -> Result<String> {
        // Only generate if idle effect is enabled and keyboard has RGB
        if !self.layout.idle_effect_settings.enabled || !self.geometry.has_rgb_matrix() {
            return Ok(String::new());
        }

        let mut code = String::new();

        code.push_str("#ifdef RGB_MATRIX_ENABLE\n");
        code.push_str("#ifdef LQMK_IDLE_TIMEOUT_MS\n");
        code.push('\n');
        code.push_str("// Idle Effect State Machine\n");
        code.push_str("typedef enum {\n");
        code.push_str("    IDLE_STATE_ACTIVE,\n");
        code.push_str("    IDLE_STATE_IDLE_EFFECT,\n");
        code.push_str("    IDLE_STATE_OFF\n");
        code.push_str("} idle_state_t;\n");
        code.push('\n');
        code.push_str("static idle_state_t idle_state = IDLE_STATE_ACTIVE;\n");
        code.push_str("static uint32_t last_activity_time = 0;\n");
        code.push('\n');

        // Matrix scan hook to check idle timeout
        code.push_str("void matrix_scan_user(void) {\n");
        code.push_str("    uint32_t elapsed = timer_elapsed32(last_activity_time);\n");
        code.push('\n');
        code.push_str("    switch (idle_state) {\n");
        code.push_str("        case IDLE_STATE_ACTIVE:\n");
        code.push_str("            if (elapsed >= LQMK_IDLE_TIMEOUT_MS) {\n");
        code.push_str("                // Transition to idle effect\n");
        code.push_str("                rgb_matrix_mode_noeeprom(LQMK_IDLE_EFFECT_MODE);\n");
        code.push_str("                idle_state = IDLE_STATE_IDLE_EFFECT;\n");
        code.push_str("            }\n");
        code.push_str("            break;\n");
        code.push('\n');
        code.push_str("        case IDLE_STATE_IDLE_EFFECT:\n");
        code.push_str(
            "            if (elapsed >= LQMK_IDLE_TIMEOUT_MS + LQMK_IDLE_EFFECT_DURATION_MS) {\n",
        );
        code.push_str("                // Transition to off\n");
        code.push_str("                rgb_matrix_disable_noeeprom();\n");
        code.push_str("                idle_state = IDLE_STATE_OFF;\n");
        code.push_str("            }\n");
        code.push_str("            break;\n");
        code.push('\n');
        code.push_str("        case IDLE_STATE_OFF:\n");
        code.push_str("            // Stay off until activity\n");
        code.push_str("            break;\n");
        code.push_str("    }\n");
        code.push_str("}\n");
        code.push('\n');

        // Process record hook to reset on activity
        code.push_str("bool process_record_user(uint16_t keycode, keyrecord_t *record) {\n");
        code.push_str("    if (record->event.pressed) {\n");
        code.push_str("        // Reset activity timer\n");
        code.push_str("        last_activity_time = timer_read32();\n");
        code.push('\n');
        code.push_str("        if (idle_state != IDLE_STATE_ACTIVE) {\n");
        code.push_str("            // Re-enable RGB if it was disabled\n");
        code.push_str("            if (idle_state == IDLE_STATE_OFF) {\n");
        code.push_str("                rgb_matrix_enable_noeeprom();\n");
        code.push_str("            }\n");
        code.push('\n');

        // Restore the appropriate mode based on whether layout has custom colors
        if self.layout_has_custom_colors() {
            code.push_str("            // Restore TUI layer colors mode\n");
            code.push_str("            rgb_matrix_mode_noeeprom(RGB_MATRIX_TUI_LAYER_COLORS);\n");
        } else {
            code.push_str("            // Restore default RGB mode\n");
            code.push_str("            rgb_matrix_mode_noeeprom(RGB_MATRIX_DEFAULT_MODE);\n");
        }

        code.push_str("            idle_state = IDLE_STATE_ACTIVE;\n");
        code.push_str("        }\n");
        code.push_str("    }\n");
        code.push('\n');
        code.push_str("    return true;\n");
        code.push_str("}\n");
        code.push('\n');

        // Keyboard post init hook to initialize timer
        code.push_str("void keyboard_post_init_user(void) {\n");
        code.push_str("    last_activity_time = timer_read32();\n");
        code.push_str("}\n");
        code.push('\n');

        code.push_str("#endif // LQMK_IDLE_TIMEOUT_MS\n");
        code.push_str("#endif // RGB_MATRIX_ENABLE\n");

        Ok(code)
    }

    /// Generates RGB overlay ripple code if enabled.
    ///
    /// Emits C code for ripple effects triggered on keypress using
    /// `rgb_matrix_indicators_advanced_user` for additive overlay rendering.
    /// The code integrates with existing `process_record_user` if present (from idle effect).
    #[allow(clippy::unnecessary_wraps)]
    #[allow(clippy::cast_possible_truncation)]
    fn generate_ripple_overlay_code(&self) -> Result<String> {
        // Only generate if ripple overlay is enabled and keyboard has RGB
        if !self.layout.rgb_overlay_ripple.enabled || !self.geometry.has_rgb_matrix() {
            return Ok(String::new());
        }

        let settings = &self.layout.rgb_overlay_ripple;
        let mut code = String::new();

        code.push_str("#ifdef RGB_MATRIX_ENABLE\n");
        code.push_str("#ifdef LQMK_RIPPLE_OVERLAY_ENABLED\n");
        code.push('\n');
        code.push_str("// RGB Overlay Ripple Configuration\n");
        code.push('\n');

        // Ripple state structure
        code.push_str("typedef struct {\n");
        code.push_str("    uint8_t led_index;\n");
        code.push_str("    uint32_t start_time;\n");
        code.push_str("    bool active;\n");
        code.push_str("} ripple_t;\n");
        code.push('\n');

        // Ripple state array
        code.push_str("static ripple_t ripples[LQMK_RIPPLE_MAX_RIPPLES] = {0};\n");
        code.push('\n');

        // Helper: Add new ripple
        code.push_str("static void lazyqmk_ripple_add(uint8_t led_index) {\n");
        code.push_str("    // Find an empty slot or the oldest ripple\n");
        code.push_str("    uint8_t oldest_idx = 0;\n");
        code.push_str("    uint32_t oldest_time = ripples[0].start_time;\n");
        code.push('\n');
        code.push_str("    for (uint8_t i = 0; i < LQMK_RIPPLE_MAX_RIPPLES; i++) {\n");
        code.push_str("        if (!ripples[i].active) {\n");
        code.push_str("            ripples[i].led_index = led_index;\n");
        code.push_str("            ripples[i].start_time = timer_read32();\n");
        code.push_str("            ripples[i].active = true;\n");
        code.push_str("            return;\n");
        code.push_str("        }\n");
        code.push_str("        if (ripples[i].start_time < oldest_time) {\n");
        code.push_str("            oldest_time = ripples[i].start_time;\n");
        code.push_str("            oldest_idx = i;\n");
        code.push_str("        }\n");
        code.push_str("    }\n");
        code.push('\n');
        code.push_str("    // Replace oldest if no empty slot\n");
        code.push_str("    ripples[oldest_idx].led_index = led_index;\n");
        code.push_str("    ripples[oldest_idx].start_time = timer_read32();\n");
        code.push_str("    ripples[oldest_idx].active = true;\n");
        code.push_str("}\n");
        code.push('\n');

        // Helper: Calculate distance between two LED indices
        code.push_str("static uint8_t lazyqmk_ripple_distance(uint8_t led1, uint8_t led2) {\n");
        code.push_str(
            "    // Simple linear distance for now (can be enhanced with X/Y coordinates)\n",
        );
        code.push_str("    return (led1 > led2) ? (led1 - led2) : (led2 - led1);\n");
        code.push_str("}\n");
        code.push('\n');

        // Helper: Apply ripple effect to LED
        code.push_str("static void lazyqmk_ripple_apply(uint8_t led_index, RGB *led_color) {\n");
        code.push_str("    uint32_t now = timer_read32();\n");
        code.push('\n');
        code.push_str("    for (uint8_t i = 0; i < LQMK_RIPPLE_MAX_RIPPLES; i++) {\n");
        code.push_str("        if (!ripples[i].active) continue;\n");
        code.push('\n');
        code.push_str("        uint32_t elapsed = now - ripples[i].start_time;\n");
        code.push_str("        if (elapsed >= LQMK_RIPPLE_DURATION_MS) {\n");
        code.push_str("            ripples[i].active = false;\n");
        code.push_str("            continue;\n");
        code.push_str("        }\n");
        code.push('\n');
        code.push_str("        // Calculate ripple radius\n");
        code.push_str("        uint8_t radius = (uint8_t)((elapsed * LQMK_RIPPLE_SPEED) / LQMK_RIPPLE_DURATION_MS);\n");
        code.push_str("        uint8_t distance = lazyqmk_ripple_distance(led_index, ripples[i].led_index);\n");
        code.push('\n');
        code.push_str("        // Check if LED is within ripple band\n");
        code.push_str(
            "        if (distance >= radius && distance < radius + LQMK_RIPPLE_BAND_WIDTH) {\n",
        );
        code.push_str("            // Calculate fade-out (1.0 at start, 0.0 at end)\n");
        code.push_str(
            "            uint8_t fade = 255 - ((elapsed * 255) / LQMK_RIPPLE_DURATION_MS);\n",
        );
        code.push('\n');
        code.push_str("            // Apply amplitude and fade\n");
        code.push_str(
            "            uint8_t brightness = (LQMK_RIPPLE_AMPLITUDE_PCT * fade) / 100;\n",
        );
        code.push('\n');

        // Apply color based on color mode
        match settings.color_mode {
            crate::models::layout::RippleColorMode::Fixed => {
                let color = &settings.fixed_color;
                code.push_str(&format!(
                    "            // Fixed color mode (R={}, G={}, B={})\n",
                    color.r, color.g, color.b
                ));
                code.push_str(&format!(
                    "            led_color->r = MIN(led_color->r + (brightness * {}) / 255, 255);\n",
                    color.r
                ));
                code.push_str(&format!(
                    "            led_color->g = MIN(led_color->g + (brightness * {}) / 255, 255);\n",
                    color.g
                ));
                code.push_str(&format!(
                    "            led_color->b = MIN(led_color->b + (brightness * {}) / 255, 255);\n",
                    color.b
                ));
            }
            crate::models::layout::RippleColorMode::KeyBased => {
                code.push_str(
                    "            // Key-based color mode (use base color, just add brightness)\n",
                );
                code.push_str("            led_color->r = MIN(led_color->r + brightness, 255);\n");
                code.push_str("            led_color->g = MIN(led_color->g + brightness, 255);\n");
                code.push_str("            led_color->b = MIN(led_color->b + brightness, 255);\n");
            }
            crate::models::layout::RippleColorMode::HueShift => {
                code.push_str(&format!(
                    "            // Hue shift mode (shift by {} degrees)\n",
                    settings.hue_shift_deg
                ));
                code.push_str(
                    "            // TODO: Implement HSV hue shift - for now use key-based\n",
                );
                code.push_str("            led_color->r = MIN(led_color->r + brightness, 255);\n");
                code.push_str("            led_color->g = MIN(led_color->g + brightness, 255);\n");
                code.push_str("            led_color->b = MIN(led_color->b + brightness, 255);\n");
            }
        }

        code.push_str("        }\n");
        code.push_str("    }\n");
        code.push_str("}\n");
        code.push('\n');

        // RGB Matrix indicators hook
        code.push_str(
            "bool rgb_matrix_indicators_advanced_user(uint8_t led_min, uint8_t led_max) {\n",
        );
        code.push_str("    for (uint8_t i = led_min; i < led_max; i++) {\n");
        code.push_str("        RGB color = {0, 0, 0};\n");
        code.push_str("        \n");
        code.push_str("        // Get base color from layer colors table\n");
        code.push_str("        uint8_t layer = get_highest_layer(layer_state);\n");
        code.push_str("        if (layer < layer_base_colors_layer_count) {\n");
        code.push_str("            color.r = pgm_read_byte(&layer_base_colors[layer][i][0]);\n");
        code.push_str("            color.g = pgm_read_byte(&layer_base_colors[layer][i][1]);\n");
        code.push_str("            color.b = pgm_read_byte(&layer_base_colors[layer][i][2]);\n");
        code.push_str("        }\n");
        code.push_str("        \n");
        code.push_str("        // Apply ripple overlay\n");
        code.push_str("        lazyqmk_ripple_apply(i, &color);\n");
        code.push_str("        \n");
        code.push_str("        rgb_matrix_set_color(i, color.r, color.g, color.b);\n");
        code.push_str("    }\n");
        code.push_str("    return false;\n");
        code.push_str("}\n");
        code.push('\n');

        // Process record hook integration
        // Check if idle effect is enabled to determine if we need to wrap or create new hook
        let has_idle_effect = self.layout.idle_effect_settings.enabled;

        if has_idle_effect {
            // Idle effect already defines process_record_user, so we add ripple trigger inside it
            code.push_str(
                "// Ripple trigger code is integrated into existing process_record_user\n",
            );
            code.push_str("// (generated by idle effect code above)\n");
            code.push_str("// Add this snippet manually or via helper function:\n");
            code.push_str("/*\n");
            code.push_str("    // Inside process_record_user, add ripple trigger:\n");
            code.push_str("    if (record->event.pressed && LQMK_RIPPLE_TRIGGER_ON_PRESS) {\n");
            code.push_str(
                "        // Get LED index for this key (requires matrix to LED mapping)\n",
            );
            code.push_str("        // For now, trigger ripple at center (LED 0)\n");
            code.push_str("        lazyqmk_ripple_add(0);\n");
            code.push_str("    }\n");
            code.push_str("*/\n");
        } else {
            // No idle effect, generate process_record_user for ripple
            code.push_str("bool process_record_user(uint16_t keycode, keyrecord_t *record) {\n");

            if settings.trigger_on_press {
                code.push_str("    if (record->event.pressed) {\n");

                // Add filters
                if settings.ignore_transparent {
                    code.push_str("        if (keycode == KC_TRNS) return true;\n");
                }
                if settings.ignore_modifiers {
                    code.push_str("        if (IS_MODIFIER_KEYCODE(keycode)) return true;\n");
                }
                if settings.ignore_layer_switch {
                    code.push_str("        if (IS_LAYER_SWITCH_KEYCODE(keycode)) return true;\n");
                }

                code.push_str("        // TODO: Get LED index from matrix position\n");
                code.push_str("        // For now, trigger ripple at center LED\n");
                code.push_str("        lazyqmk_ripple_add(RGB_MATRIX_LED_COUNT / 2);\n");
                code.push_str("    }\n");
            }

            if settings.trigger_on_release {
                code.push_str("    if (!record->event.pressed) {\n");
                code.push_str("        // TODO: Get LED index from matrix position\n");
                code.push_str("        lazyqmk_ripple_add(RGB_MATRIX_LED_COUNT / 2);\n");
                code.push_str("    }\n");
            }

            code.push_str("    return true;\n");
            code.push_str("}\n");
            code.push('\n');
        }

        code.push_str("#endif // LQMK_RIPPLE_OVERLAY_ENABLED\n");
        code.push_str("#endif // RGB_MATRIX_ENABLE\n");

        Ok(code)
    }

    /// Generates tap dance enum definition.
    ///
    /// Creates `enum tap_dance_ids { TD_NAME1, TD_NAME2, ... };`
    /// Names are sorted alphabetically for stable ordering.
    fn generate_tap_dance_enum(&self) -> String {
        if self.layout.tap_dances.is_empty() {
            return String::new();
        }

        let mut code = String::new();
        code.push_str("enum tap_dance_ids {\n");

        // Sort tap dances by name for stable enum ordering
        let mut sorted_tds: Vec<_> = self.layout.tap_dances.iter().collect();
        sorted_tds.sort_by_key(|td| &td.name);

        for (idx, td) in sorted_tds.iter().enumerate() {
            let enum_name = format!("TD_{}", td.name.to_uppercase());
            code.push_str(&format!("    {}", enum_name));
            if idx < sorted_tds.len() - 1 {
                code.push(',');
            }
            code.push('\n');
        }

        code.push_str("};\n");
        code
    }

    /// Generates helper functions for 3-way tap dances (with hold behavior).
    ///
    /// For each tap dance that has a hold action, generates finished/reset callback functions.
    fn generate_tap_dance_helpers(&self) -> String {
        let mut code = String::new();

        // Sort tap dances by name for consistent output
        let mut sorted_tds: Vec<_> = self.layout.tap_dances.iter().collect();
        sorted_tds.sort_by_key(|td| &td.name);

        for td in sorted_tds {
            // Only generate helper functions for 3-way tap dances (those with hold)
            if td.hold.is_none() {
                continue;
            }

            let name_lower = td.name.to_lowercase();
            let single_tap = &td.single_tap;
            let double_tap = td.double_tap.as_ref().unwrap(); // 3-way always has double_tap
            let hold = td.hold.as_ref().unwrap();

            // Generate finished function
            code.push_str(&format!(
                "void td_{}_finished(tap_dance_state_t *state, void *user_data) {{\n",
                name_lower
            ));
            code.push_str("    if (state->count == 1) {\n");
            code.push_str("        if (state->interrupted || !state->pressed) {\n");
            code.push_str(&format!("            register_code16({});\n", single_tap));
            code.push_str("        } else {\n");
            code.push_str(&format!("            register_code16({});\n", hold));
            code.push_str("        }\n");
            code.push_str("    } else if (state->count == 2) {\n");
            code.push_str(&format!("        register_code16({});\n", double_tap));
            code.push_str("    }\n");
            code.push_str("}\n\n");

            // Generate reset function
            code.push_str(&format!(
                "void td_{}_reset(tap_dance_state_t *state, void *user_data) {{\n",
                name_lower
            ));
            code.push_str("    if (state->count == 1) {\n");
            code.push_str(&format!("        unregister_code16({});\n", single_tap));
            code.push_str(&format!("        unregister_code16({});\n", hold));
            code.push_str("    } else if (state->count == 2) {\n");
            code.push_str(&format!("        unregister_code16({});\n", double_tap));
            code.push_str("    }\n");
            code.push_str("}\n\n");
        }

        code
    }

    /// Generates tap dance actions array.
    ///
    /// Creates `tap_dance_action_t tap_dance_actions[] = { ... };`
    /// Uses ACTION_TAP_DANCE_DOUBLE for 2-way, ACTION_TAP_DANCE_FN_ADVANCED for 3-way.
    fn generate_tap_dance_actions(&self) -> String {
        if self.layout.tap_dances.is_empty() {
            return String::new();
        }

        let mut code = String::new();
        code.push_str("tap_dance_action_t tap_dance_actions[] = {\n");

        // Sort tap dances by name to match enum ordering
        let mut sorted_tds: Vec<_> = self.layout.tap_dances.iter().collect();
        sorted_tds.sort_by_key(|td| &td.name);

        for (idx, td) in sorted_tds.iter().enumerate() {
            let enum_name = format!("TD_{}", td.name.to_uppercase());

            let action = if td.has_hold() {
                // 3-way tap dance: ACTION_TAP_DANCE_FN_ADVANCED(NULL, finished, reset)
                let name_lower = td.name.to_lowercase();
                format!(
                    "ACTION_TAP_DANCE_FN_ADVANCED(NULL, td_{}_finished, td_{}_reset)",
                    name_lower, name_lower
                )
            } else if let Some(double) = &td.double_tap {
                // 2-way tap dance: ACTION_TAP_DANCE_DOUBLE(single, double)
                let single = &td.single_tap;
                format!("ACTION_TAP_DANCE_DOUBLE({}, {})", single, double)
            } else {
                // Single-tap-only fallback: treat as double with same keycode to avoid helper fns
                let single = &td.single_tap;
                format!("ACTION_TAP_DANCE_DOUBLE({}, {})", single, single)
            };

            code.push_str(&format!("    [{}] = {}", enum_name, action));
            if idx < sorted_tds.len() - 1 {
                code.push(',');
            }
            code.push('\n');
        }

        code.push_str("};\n");
        code
    }

    /// Processes a keycode, converting TD(name) references to TD(TD_NAME_UPPER).
    ///
    /// Validates that the referenced tap dance exists in the layout.
    fn process_keycode_for_tap_dance(&self, keycode: &str) -> String {
        // Try to parse as tap dance keycode
        if let Some(name) = self.keycode_db.parse_tap_dance_keycode(keycode) {
            // Validate that this tap dance exists in the layout
            if self.layout.get_tap_dance(&name).is_some() {
                // Convert TD(name) -> TD(TD_NAME)
                let enum_name = format!("TD_{}", name.to_uppercase());
                return format!("TD({})", enum_name);
            }
            // If tap dance doesn't exist, return original (will be caught by validator)
        }

        // Not a tap dance keycode, return unchanged
        keycode.to_string()
    }

    /// Generates config.h for the keymap.
    ///
    /// This generates a minimal keymap-specific config.h.
    /// Note: `RGB_MATRIX_LED_COUNT` should be defined in the keyboard's variant-specific
    /// keyboard.json file, not in the keymap config.h.
    #[allow(clippy::cast_possible_truncation)]
    pub fn generate_merged_config_h(&self) -> Result<String> {
        use crate::models::HoldDecisionMode;

        let mut content = String::new();

        // Add our generated configuration
        content.push_str(&format!("// Generated by {}\n", APP_BINARY_NAME));
        content.push_str(&format!("// Layout: {}\n", self.layout.metadata.name));
        content.push_str(&format!(
            "// Generated: {}\n",
            chrono::Local::now().format("%Y-%m-%d %H:%M:%S")
        ));
        content.push('\n');
        content.push_str("#pragma once\n");
        content.push('\n');
        content.push_str("// Add keymap-specific configuration here\n");

        // === Tap-Hold Settings ===
        let ths = &self.layout.tap_hold_settings;

        // Validate tap-hold settings before generating
        ths.validate()?;

        // Only emit non-default tap-hold settings
        if ths.has_custom_settings() {
            content.push_str("\n// Tap-Hold Configuration\n");

            // Tapping Term
            if ths.has_custom_tapping_term() {
                content.push_str(&format!("#define TAPPING_TERM {}\n", ths.tapping_term));
            }

            // Quick Tap Term
            if ths.has_custom_quick_tap_term() {
                if let Some(term) = ths.quick_tap_term {
                    content.push_str(&format!("#define QUICK_TAP_TERM {term}\n"));
                }
                // None means use TAPPING_TERM (QMK default), no need to emit
            }

            // Hold Mode - use config_define() to get the #define name
            if ths.hold_mode != HoldDecisionMode::Default {
                if let Some(define_name) = ths.hold_mode.config_define() {
                    content.push_str(&format!("#define {define_name}\n"));
                }
            }

            // Retro Tapping - only emit if enabled
            if ths.retro_tapping {
                content.push_str("#define RETRO_TAPPING\n");
            }

            // Tapping Toggle - only emit if different from default (5)
            if ths.tapping_toggle != 5 {
                content.push_str(&format!("#define TAPPING_TOGGLE {}\n", ths.tapping_toggle));
            }

            // Flow Tap Term (QMK 0.26+)
            if let Some(term) = ths.flow_tap_term {
                content.push_str(&format!("#define FLOW_TAP_TERM {term}\n"));
            }

            // Chordal Hold (QMK 0.26+) - only emit if enabled
            if ths.chordal_hold {
                content.push_str("#define CHORDAL_HOLD\n");
            }
        }

        // === RGB Settings ===
        // RGB Matrix brightness (0-255, converted from 0-100%)
        let brightness_255 = (u16::from(self.layout.rgb_brightness.as_percent()) * 255 / 100) as u8;
        if brightness_255 < 255 {
            content.push_str("\n// RGB Matrix Maximum Brightness\n");
            content.push_str(&format!(
                "#define RGB_MATRIX_MAXIMUM_BRIGHTNESS {}\n",
                brightness_255
            ));
        }

        // === Idle Effect Settings ===
        // When idle effect is enabled, we use a custom state machine instead of RGB_MATRIX_TIMEOUT
        let idle_settings = &self.layout.idle_effect_settings;
        if idle_settings.enabled && self.geometry.has_rgb_matrix() {
            content.push_str("\n// Idle Effect Configuration\n");
            content.push_str(&format!(
                "#define LQMK_IDLE_TIMEOUT_MS {}\n",
                idle_settings.idle_timeout_ms
            ));
            content.push_str(&format!(
                "#define LQMK_IDLE_EFFECT_DURATION_MS {}\n",
                idle_settings.idle_effect_duration_ms
            ));
            content.push_str(&format!(
                "#define LQMK_IDLE_EFFECT_MODE {}\n",
                idle_settings.idle_effect_mode.qmk_mode_name()
            ));
        } else {
            // RGB Matrix timeout (auto-off after inactivity) - only when idle effect is disabled
            if self.layout.rgb_timeout_ms > 0 {
                content.push_str("\n// RGB Matrix Timeout (auto-off after inactivity)\n");
                content.push_str(&format!(
                    "#define RGB_MATRIX_TIMEOUT {}\n",
                    self.layout.rgb_timeout_ms
                ));
            }
        }

        // If the keyboard has RGB matrix and the layout defines
        // any custom colors, default to the TUI-driven lighting
        // mode so firmware reflects the editor by default.
        if self.geometry.has_rgb_matrix() && self.layout_has_custom_colors() {
            content.push_str("\n// Default to TUI layer-aware RGB colors when available\n");
            content.push_str("#ifdef RGB_MATRIX_ENABLE\n");
            content.push_str("#    undef RGB_MATRIX_DEFAULT_MODE\n");
            content.push_str("#    define RGB_MATRIX_DEFAULT_MODE RGB_MATRIX_TUI_LAYER_COLORS\n");
            content.push_str("#    define LAYER_BASE_COLORS_LAYER_COUNT ");
            content.push_str(&format!("{}\n", self.layout.layers.len()));
            content.push_str("#endif\n");
        }

        // === RGB Overlay Ripple Settings ===
        let ripple_settings = &self.layout.rgb_overlay_ripple;
        if ripple_settings.enabled && self.geometry.has_rgb_matrix() {
            // Validate settings before generating
            ripple_settings.validate()?;

            content.push_str("\n// RGB Overlay Ripple Configuration\n");
            content.push_str("#define LQMK_RIPPLE_OVERLAY_ENABLED\n");
            content.push_str(&format!(
                "#define LQMK_RIPPLE_MAX_RIPPLES {}\n",
                ripple_settings.max_ripples
            ));
            content.push_str(&format!(
                "#define LQMK_RIPPLE_DURATION_MS {}\n",
                ripple_settings.duration_ms
            ));
            content.push_str(&format!(
                "#define LQMK_RIPPLE_SPEED {}\n",
                ripple_settings.speed
            ));
            content.push_str(&format!(
                "#define LQMK_RIPPLE_BAND_WIDTH {}\n",
                ripple_settings.band_width
            ));
            content.push_str(&format!(
                "#define LQMK_RIPPLE_AMPLITUDE_PCT {}\n",
                ripple_settings.amplitude_pct
            ));
            content.push_str(&format!(
                "#define LQMK_RIPPLE_TRIGGER_ON_PRESS {}\n",
                if ripple_settings.trigger_on_press {
                    "1"
                } else {
                    "0"
                }
            ));
            content.push_str(&format!(
                "#define LQMK_RIPPLE_TRIGGER_ON_RELEASE {}\n",
                if ripple_settings.trigger_on_release {
                    "1"
                } else {
                    "0"
                }
            ));
        }

        Ok(content)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::keyboard_geometry::KeyGeometry;
    use crate::models::layer::{KeyDefinition, Layer, Position};
    use crate::models::RgbColor;
    use std::path::PathBuf;

    fn create_test_setup() -> (
        Layout,
        KeyboardGeometry,
        VisualLayoutMapping,
        Config,
        KeycodeDb,
    ) {
        let mut layout = Layout::new("Test").unwrap();

        // Set keyboard metadata needed for firmware generation
        layout.metadata.keyboard = Some("test".to_string());
        layout.metadata.layout_variant = Some("LAYOUT".to_string());
        layout.metadata.keymap_name = Some("default".to_string());
        layout.metadata.output_format = Some("uf2".to_string());

        let mut layer = Layer::new(0, "Base", RgbColor::new(255, 255, 255)).unwrap();
        layer.add_key(KeyDefinition::new(Position::new(0, 0), "KC_A"));
        layer.add_key(KeyDefinition::new(Position::new(0, 1), "KC_B"));
        layout.add_layer(layer).unwrap();

        let mut geometry = KeyboardGeometry::new("test", "LAYOUT", 2, 2);
        geometry.add_key(KeyGeometry::new((0, 0), 0, 0.0, 0.0));
        geometry.add_key(KeyGeometry::new((0, 1), 1, 1.0, 0.0));
        geometry.encoder_count = 4; // Set encoder count for tests

        let mapping = VisualLayoutMapping::build(&geometry);

        let mut config = Config::default();
        config.paths.qmk_firmware = Some(PathBuf::from("/tmp/qmk_test"));

        let keycode_db = KeycodeDb::load().expect("Failed to load keycode database");

        (layout, geometry, mapping, config, keycode_db)
    }

    #[test]
    fn test_generate_keymap_c() {
        let (layout, geometry, mapping, config, keycode_db) = create_test_setup();
        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);

        let keymap_c = generator.generate_keymap_c().unwrap();

        // Verify header
        assert!(keymap_c.contains("// Generated by lazyqmk"));
        assert!(keymap_c.contains("// Layout: Test"));
        assert!(keymap_c.contains("#include QMK_KEYBOARD_H"));

        // Verify keymap structure
        assert!(keymap_c.contains("const uint16_t PROGMEM keymaps[]"));
        assert!(keymap_c.contains("[0] = LAYOUT("));
        assert!(keymap_c.contains("KC_A"));
        assert!(keymap_c.contains("KC_B"));

        // Verify encoder_map is included
        assert!(keymap_c.contains("#ifdef ENCODER_MAP_ENABLE"));
        assert!(keymap_c.contains("const uint16_t PROGMEM encoder_map[]"));
        assert!(keymap_c.contains("ENCODER_CCW_CW(RM_NEXT, RM_PREV)"));
        assert!(keymap_c.contains("#endif"));

        // Verify RGB matrix base color table is included for RGB keyboards
        assert!(keymap_c.contains("#ifdef RGB_MATRIX_ENABLE"));
        assert!(keymap_c.contains("const uint8_t PROGMEM layer_base_colors"));
        assert!(keymap_c.contains("#endif"));
    }

    #[test]
    fn test_generate_merged_config_h_sets_default_mode_when_colored_and_rgb() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Mark layout as "colored" by changing the default color
        // and adding a category used by a key.
        let nav_color = RgbColor::new(0, 255, 0);
        let category = crate::models::Category::new("navigation", "Navigation", nav_color).unwrap();
        layout.add_category(category).unwrap();
        layout
            .get_layer_mut(0)
            .unwrap()
            .get_key_mut(Position::new(0, 1))
            .unwrap()
            .category_id = Some("navigation".to_string());

        // RGB-capable geometry: already has two keys in create_test_setup.
        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let config_h = generator.generate_merged_config_h().unwrap();

        assert!(config_h.contains("RGB_MATRIX_TUI_LAYER_COLORS"));
        assert!(
            config_h.contains("#    define RGB_MATRIX_DEFAULT_MODE RGB_MATRIX_TUI_LAYER_COLORS")
        );
    }

    #[test]
    fn test_generate_merged_config_h_does_not_set_default_mode_without_colors_or_rgb() {
        let (layout, mut geometry, mapping, config, keycode_db) = create_test_setup();

        // Remove all keys from geometry so has_rgb_matrix() is false.
        geometry.keys.clear();

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let config_h = generator.generate_merged_config_h().unwrap();

        assert!(!config_h.contains("RGB_MATRIX_TUI_LAYER_COLORS"));
        assert!(!config_h.contains("RGB_MATRIX_DEFAULT_MODE"));
    }

    #[test]
    fn test_generate_layer_colors_by_led_uses_resolved_colors() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Add a category and assign it to the second key so we can
        // verify that resolve_key_color logic is respected.
        let nav_color = RgbColor::new(0, 255, 0);
        let category = crate::models::Category::new("navigation", "Navigation", nav_color).unwrap();
        layout.add_category(category).unwrap();

        // Update key on layer 0, position (0, 1) to use the category.
        layout
            .get_layer_mut(0)
            .unwrap()
            .get_key_mut(Position::new(0, 1))
            .unwrap()
            .category_id = Some("navigation".to_string());

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let colors_by_led = generator.generate_layer_colors_by_led(0).unwrap();

        assert_eq!(colors_by_led.len(), 2);
        // First key uses layer default color (white from create_test_setup).
        assert_eq!(colors_by_led[0], RgbColor::new(255, 255, 255));
        // Second key uses category color.
        assert_eq!(colors_by_led[1], nav_color);
    }

    #[test]
    fn test_generate_rgb_matrix_color_table_structure() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Add a second layer with a different default color
        let mut layer2 = Layer::new(1, "Navigation", RgbColor::new(0, 128, 255)).unwrap();
        layer2.add_key(KeyDefinition::new(Position::new(0, 0), "KC_LEFT"));
        layer2.add_key(KeyDefinition::new(Position::new(0, 1), "KC_RIGHT"));
        layout.add_layer(layer2).unwrap();

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let color_table = generator.generate_rgb_matrix_color_table().unwrap();

        // Verify structure
        assert!(color_table.contains("#ifdef RGB_MATRIX_ENABLE"));
        assert!(color_table.contains("#endif"));
        assert!(color_table.contains("const uint8_t PROGMEM layer_base_colors[2][2][3]"));
        assert!(color_table.contains("layer_base_colors_layer_count = 2;"));

        // Verify layer 0 colors (white default)
        assert!(color_table.contains("{255, 255, 255}"));
        // Verify layer 1 colors (blue-ish default)
        assert!(color_table.contains("{  0, 128, 255}"));
    }

    #[test]
    fn test_generate_rgb_matrix_color_table_empty_for_non_rgb() {
        let (layout, mut geometry, mapping, config, keycode_db) = create_test_setup();

        // Remove keys to simulate non-RGB keyboard
        geometry.keys.clear();

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let color_table = generator.generate_rgb_matrix_color_table().unwrap();

        // Should be empty for non-RGB keyboards
        assert!(color_table.is_empty());
    }

    #[test]
    fn test_layout_has_custom_colors_with_category() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Initially should have no custom colors (just white default)
        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        assert!(!generator.layout_has_custom_colors());

        // Add a category
        let category =
            crate::models::Category::new("nav", "Navigation", RgbColor::new(0, 255, 0)).unwrap();
        layout.add_category(category).unwrap();

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        assert!(generator.layout_has_custom_colors());
    }

    #[test]
    fn test_layout_has_custom_colors_with_layer_default() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Change layer default color from white
        layout.get_layer_mut(0).unwrap().default_color = RgbColor::new(128, 128, 128);

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        assert!(generator.layout_has_custom_colors());
    }

    #[test]
    fn test_layout_has_custom_colors_with_key_override() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Add key color override
        layout
            .get_layer_mut(0)
            .unwrap()
            .get_key_mut(Position::new(0, 0))
            .unwrap()
            .color_override = Some(RgbColor::new(255, 0, 0));

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        assert!(generator.layout_has_custom_colors());
    }

    #[test]
    fn test_generate_layer_colors_respects_priority_order() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Set up all four color levels for key at (0, 1):
        // 1. Global default is white (255, 255, 255)
        // 2. Layer default: blue
        layout.get_layer_mut(0).unwrap().default_color = RgbColor::new(0, 0, 255);

        // 3. Category: green
        let category =
            crate::models::Category::new("nav", "Navigation", RgbColor::new(0, 255, 0)).unwrap();
        layout.add_category(category).unwrap();
        layout
            .get_layer_mut(0)
            .unwrap()
            .get_key_mut(Position::new(0, 1))
            .unwrap()
            .category_id = Some("nav".to_string());

        // 4. Key override: red (highest priority)
        layout
            .get_layer_mut(0)
            .unwrap()
            .get_key_mut(Position::new(0, 1))
            .unwrap()
            .color_override = Some(RgbColor::new(255, 0, 0));

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let colors = generator.generate_layer_colors_by_led(0).unwrap();

        // Key at LED 0 should use layer default (blue) since no category or override
        assert_eq!(colors[0], RgbColor::new(0, 0, 255));

        // Key at LED 1 should use override (red) - highest priority
        assert_eq!(colors[1], RgbColor::new(255, 0, 0));
    }

    #[test]
    fn test_keymap_c_includes_rgb_table_when_rgb_enabled() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Add category to trigger custom colors
        let category =
            crate::models::Category::new("nav", "Navigation", RgbColor::new(0, 255, 0)).unwrap();
        layout.add_category(category).unwrap();

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let keymap_c = generator.generate_keymap_c().unwrap();

        // Should include RGB matrix color table
        assert!(keymap_c.contains("#ifdef RGB_MATRIX_ENABLE"));
        assert!(keymap_c.contains("layer_base_colors"));
        assert!(keymap_c.contains("layer_base_colors_layer_count"));
    }

    #[test]
    fn test_config_h_sets_tui_layer_colors_mode() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Add category to trigger custom colors
        let category =
            crate::models::Category::new("nav", "Navigation", RgbColor::new(0, 255, 0)).unwrap();
        layout.add_category(category).unwrap();

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let config_h = generator.generate_merged_config_h().unwrap();

        // Should set the TUI layer colors mode as default
        assert!(config_h.contains("RGB_MATRIX_TUI_LAYER_COLORS"));
        assert!(
            config_h.contains("#    define RGB_MATRIX_DEFAULT_MODE RGB_MATRIX_TUI_LAYER_COLORS")
        );
        assert!(config_h.contains("LAYER_BASE_COLORS_LAYER_COUNT 1"));
    }

    #[test]
    fn test_multi_layer_color_table_generation() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Layer 0: White default
        // Layer 1: Red default
        let mut layer1 = Layer::new(1, "Red Layer", RgbColor::new(255, 0, 0)).unwrap();
        layer1.add_key(KeyDefinition::new(Position::new(0, 0), "KC_1"));
        layer1.add_key(KeyDefinition::new(Position::new(0, 1), "KC_2"));
        layout.add_layer(layer1).unwrap();

        // Layer 2: Green default
        let mut layer2 = Layer::new(2, "Green Layer", RgbColor::new(0, 255, 0)).unwrap();
        layer2.add_key(KeyDefinition::new(Position::new(0, 0), "KC_3"));
        layer2.add_key(KeyDefinition::new(Position::new(0, 1), "KC_4"));
        layout.add_layer(layer2).unwrap();

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let color_table = generator.generate_rgb_matrix_color_table().unwrap();

        // Verify 3 layers
        assert!(color_table.contains("layer_base_colors[3][2][3]"));
        assert!(color_table.contains("layer_base_colors_layer_count = 3;"));

        // Verify each layer's colors are present
        assert!(color_table.contains("{255, 255, 255}")); // White
        assert!(color_table.contains("{255,   0,   0}")); // Red
        assert!(color_table.contains("{  0, 255,   0}")); // Green
    }

    #[test]
    fn test_config_h_emits_tap_hold_settings() {
        use crate::models::{TapHoldPreset, TapHoldSettings};

        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Apply HomeRowMods preset
        layout.tap_hold_settings = TapHoldSettings::from_preset(TapHoldPreset::HomeRowMods);

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let config_h = generator.generate_merged_config_h().unwrap();

        // Verify tap-hold settings are emitted
        assert!(config_h.contains("// Tap-Hold Configuration"));
        assert!(config_h.contains("#define TAPPING_TERM 175"));
        assert!(config_h.contains("#define QUICK_TAP_TERM 120"));
        assert!(config_h.contains("#define PERMISSIVE_HOLD"));
        assert!(config_h.contains("#define RETRO_TAPPING"));
        assert!(config_h.contains("#define FLOW_TAP_TERM 150"));
        assert!(config_h.contains("#define CHORDAL_HOLD"));
    }

    #[test]
    fn test_config_h_does_not_emit_default_tap_hold() {
        let (layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Layout has default tap-hold settings
        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let config_h = generator.generate_merged_config_h().unwrap();

        // Should NOT contain tap-hold defines
        assert!(!config_h.contains("TAPPING_TERM"));
        assert!(!config_h.contains("QUICK_TAP_TERM"));
        assert!(!config_h.contains("PERMISSIVE_HOLD"));
        assert!(!config_h.contains("RETRO_TAPPING"));
    }

    #[test]
    fn test_config_h_emits_hold_on_other_key_press() {
        use crate::models::{HoldDecisionMode, TapHoldSettings};

        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Set up custom tap-hold settings with HoldOnOtherKeyPress
        layout.tap_hold_settings = TapHoldSettings {
            tapping_term: 150,
            hold_mode: HoldDecisionMode::HoldOnOtherKeyPress,
            ..TapHoldSettings::default()
        };

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let config_h = generator.generate_merged_config_h().unwrap();

        assert!(config_h.contains("#define TAPPING_TERM 150"));
        assert!(config_h.contains("#define HOLD_ON_OTHER_KEY_PRESS"));
        assert!(!config_h.contains("PERMISSIVE_HOLD"));
    }

    #[test]
    fn test_config_h_emits_tapping_toggle() {
        use crate::models::TapHoldSettings;

        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Change tapping toggle from default (5) to 3
        layout.tap_hold_settings = TapHoldSettings {
            tapping_toggle: 3,
            ..TapHoldSettings::default()
        };

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let config_h = generator.generate_merged_config_h().unwrap();

        assert!(config_h.contains("#define TAPPING_TOGGLE 3"));
    }

    #[test]
    fn test_detect_required_headers_no_language_keycodes() {
        let (layout, geometry, mapping, config, keycode_db) = create_test_setup();
        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);

        let headers = generator.detect_required_headers();
        assert!(headers.is_empty());
    }

    #[test]
    fn test_detect_required_headers_german_keycodes() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Add German keycodes to layer
        layout
            .get_layer_mut(0)
            .unwrap()
            .get_key_mut(Position::new(0, 0))
            .unwrap()
            .keycode = "DE_Y".to_string();

        layout
            .get_layer_mut(0)
            .unwrap()
            .get_key_mut(Position::new(0, 1))
            .unwrap()
            .keycode = "DE_UDIA".to_string();

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let headers = generator.detect_required_headers();

        assert_eq!(headers.len(), 1);
        assert!(headers.iter().any(|h| h.contains("keymap_german")));
    }

    #[test]
    fn test_detect_required_headers_german_in_layer_tap() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Add German keycode inside LT()
        layout
            .get_layer_mut(0)
            .unwrap()
            .get_key_mut(Position::new(0, 0))
            .unwrap()
            .keycode = "LT(1, DE_A)".to_string();

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let headers = generator.detect_required_headers();

        assert_eq!(headers.len(), 1);
        assert!(headers.iter().any(|h| h.contains("keymap_german")));
    }

    #[test]
    fn test_generate_keymap_c_includes_language_headers() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Add German keycode
        layout
            .get_layer_mut(0)
            .unwrap()
            .get_key_mut(Position::new(0, 0))
            .unwrap()
            .keycode = "DE_Y".to_string();

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let keymap_c = generator.generate_keymap_c().unwrap();

        // Verify the German header is included
        assert!(keymap_c.contains("#include QMK_KEYBOARD_H"));
        assert!(keymap_c.contains("#include \"keymap_extras/keymap_german.h\""));
    }

    #[test]
    fn test_generate_keymap_c_no_extra_headers_without_language_keycodes() {
        let (layout, geometry, mapping, config, keycode_db) = create_test_setup();
        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let keymap_c = generator.generate_keymap_c().unwrap();

        // Should only have the standard include
        assert!(keymap_c.contains("#include QMK_KEYBOARD_H"));
        assert!(!keymap_c.contains("keymap_extras"));
    }

    // === Idle Effect Tests ===

    #[test]
    fn test_idle_effect_disabled_no_code() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();
        layout.idle_effect_settings.enabled = false;

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let keymap_c = generator.generate_keymap_c().unwrap();

        // Should not contain idle effect code
        assert!(!keymap_c.contains("idle_state_t"));
        assert!(!keymap_c.contains("IDLE_STATE_ACTIVE"));
    }

    #[test]
    fn test_idle_effect_enabled_generates_code() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();
        layout.idle_effect_settings.enabled = true;
        layout.idle_effect_settings.idle_timeout_ms = 30_000;
        layout.idle_effect_settings.idle_effect_duration_ms = 60_000;
        layout.idle_effect_settings.idle_effect_mode = crate::models::RgbMatrixEffect::Breathing;

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let keymap_c = generator.generate_keymap_c().unwrap();

        // Should contain idle effect state machine
        assert!(keymap_c.contains("idle_state_t"));
        assert!(keymap_c.contains("IDLE_STATE_ACTIVE"));
        assert!(keymap_c.contains("IDLE_STATE_IDLE_EFFECT"));
        assert!(keymap_c.contains("IDLE_STATE_OFF"));
        assert!(keymap_c.contains("matrix_scan_user"));
        assert!(keymap_c.contains("process_record_user"));
        assert!(keymap_c.contains("keyboard_post_init_user"));
        assert!(keymap_c.contains("last_activity_time"));
    }

    #[test]
    fn test_idle_effect_config_defines() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();
        layout.idle_effect_settings.enabled = true;
        layout.idle_effect_settings.idle_timeout_ms = 45_000;
        layout.idle_effect_settings.idle_effect_duration_ms = 180_000;
        layout.idle_effect_settings.idle_effect_mode =
            crate::models::RgbMatrixEffect::RainbowBeacon;

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let config_h = generator.generate_merged_config_h().unwrap();

        // Should contain idle effect defines
        assert!(config_h.contains("#define LQMK_IDLE_TIMEOUT_MS 45000"));
        assert!(config_h.contains("#define LQMK_IDLE_EFFECT_DURATION_MS 180000"));
        assert!(config_h.contains("#define LQMK_IDLE_EFFECT_MODE RGB_MATRIX_RAINBOW_BEACON"));
    }

    #[test]
    fn test_idle_effect_no_rgb_matrix_timeout_conflict() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();
        layout.idle_effect_settings.enabled = true;
        layout.rgb_timeout_ms = 60_000; // This should be ignored when idle effect is enabled

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let config_h = generator.generate_merged_config_h().unwrap();

        // Should contain idle effect defines
        assert!(config_h.contains("LQMK_IDLE_TIMEOUT_MS"));

        // Should NOT contain RGB_MATRIX_TIMEOUT when idle effect is enabled
        assert!(!config_h.contains("#define RGB_MATRIX_TIMEOUT"));
    }

    #[test]
    fn test_rgb_matrix_timeout_when_idle_disabled() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();
        layout.idle_effect_settings.enabled = false;
        layout.rgb_timeout_ms = 120_000;

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let config_h = generator.generate_merged_config_h().unwrap();

        // Should contain RGB_MATRIX_TIMEOUT when idle effect is disabled
        assert!(config_h.contains("#define RGB_MATRIX_TIMEOUT 120000"));

        // Should NOT contain idle effect defines
        assert!(!config_h.contains("LQMK_IDLE_TIMEOUT_MS"));
    }

    #[test]
    fn test_idle_effect_restores_tui_colors() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();

        // Add category to trigger custom colors
        let category =
            crate::models::Category::new("nav", "Navigation", RgbColor::new(0, 255, 0)).unwrap();
        layout.add_category(category).unwrap();

        layout.idle_effect_settings.enabled = true;

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let keymap_c = generator.generate_keymap_c().unwrap();

        // Should restore TUI layer colors mode on activity
        assert!(keymap_c.contains("rgb_matrix_mode_noeeprom(RGB_MATRIX_TUI_LAYER_COLORS)"));
    }

    #[test]
    fn test_idle_effect_restores_default_mode() {
        let (mut layout, geometry, mapping, config, keycode_db) = create_test_setup();
        layout.idle_effect_settings.enabled = true;

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let keymap_c = generator.generate_keymap_c().unwrap();

        // Should restore default mode when no custom colors
        assert!(keymap_c.contains("rgb_matrix_mode_noeeprom(RGB_MATRIX_DEFAULT_MODE)"));
    }

    #[test]
    fn test_idle_effect_no_rgb_keyboard() {
        let (mut layout, mut geometry, mapping, config, keycode_db) = create_test_setup();

        // Remove keys to simulate non-RGB keyboard
        geometry.keys.clear();

        layout.idle_effect_settings.enabled = true;

        let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
        let keymap_c = generator.generate_keymap_c().unwrap();
        let config_h = generator.generate_merged_config_h().unwrap();

        // Should not generate idle effect code for non-RGB keyboard
        assert!(!keymap_c.contains("idle_state_t"));
        assert!(!config_h.contains("LQMK_IDLE_TIMEOUT_MS"));
    }

    // TODO: Re-enable these tests once encoder_count field is added to KeyboardGeometry
    // #[test]
    // fn test_generate_encoder_map_with_zero_encoders() {
    //     let (layout, mut geometry, mapping, config, keycode_db) = create_test_setup();
    //     geometry.encoder_count = 0;

    //     let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
    //     let encoder_map = generator.generate_conditional_encoder_map().unwrap();

    //     // Should still have the ifdef wrapper
    //     assert!(encoder_map.contains("#ifdef ENCODER_MAP_ENABLE"));
    //     assert!(encoder_map.contains("#endif"));
    //     // But should have no encoder bindings
    //     assert!(!encoder_map.contains("ENCODER_CCW_CW"));
    // }

    // #[test]
    // fn test_generate_encoder_map_with_one_encoder() {
    //     let (layout, mut geometry, mapping, config, keycode_db) = create_test_setup();
    //     geometry.encoder_count = 1;

    //     let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
    //     let encoder_map = generator.generate_conditional_encoder_map().unwrap();

    //     // Should have exactly one encoder binding per layer
    //     assert!(encoder_map.contains("ENCODER_CCW_CW(RM_NEXT, RM_PREV)"));
    //     // Should NOT have the second encoder
    //     assert!(!encoder_map.contains("ENCODER_CCW_CW(RM_HUEU, RM_HUED)"));
    // }

    // #[test]
    // fn test_generate_encoder_map_with_four_encoders() {
    //     let (layout, mut geometry, mapping, config, keycode_db) = create_test_setup();
    //     geometry.encoder_count = 4;

    //     let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
    //     let encoder_map = generator.generate_conditional_encoder_map().unwrap();

    //     // Should have all four default encoder bindings
    //     assert!(encoder_map.contains("ENCODER_CCW_CW(RM_NEXT, RM_PREV)"));
    //     assert!(encoder_map.contains("ENCODER_CCW_CW(RM_HUEU, RM_HUED)"));
    //     assert!(encoder_map.contains("ENCODER_CCW_CW(RM_VALU, RM_VALD)"));
    //     assert!(encoder_map.contains("ENCODER_CCW_CW(RM_SATU, RM_SATD)"));
    // }

    // #[test]
    // fn test_generate_encoder_map_with_multiple_layers() {
    //     let (mut layout, mut geometry, mapping, config, keycode_db) = create_test_setup();
    //     geometry.encoder_count = 2;

    //     // Add a second layer
    //     let mut layer2 = Layer::new(1, "Layer 2", RgbColor::new(0, 255, 0)).unwrap();
    //     layer2.add_key(KeyDefinition::new(Position::new(0, 0), "KC_1"));
    //     layer2.add_key(KeyDefinition::new(Position::new(0, 1), "KC_2"));
    //     layout.add_layer(layer2).unwrap();

    //     let generator = FirmwareGenerator::new(&layout, &geometry, &mapping, &config, &keycode_db);
    //     let encoder_map = generator.generate_conditional_encoder_map().unwrap();

    //     // Count occurrences of "[0] =" and "[1] =" to verify both layers
    //     let layer0_count = encoder_map.matches("[0] =").count();
    //     let layer1_count = encoder_map.matches("[1] =").count();

    //     assert_eq!(layer0_count, 1, "Should have one layer 0 definition");
    //     assert_eq!(layer1_count, 1, "Should have one layer 1 definition");

    //     // Each layer should have 2 encoder bindings
    //     let encoder_count = encoder_map.matches("ENCODER_CCW_CW").count();
    //     assert_eq!(encoder_count, 4, "Should have 2 encoders * 2 layers = 4 total bindings");
    // }
}
