[package]
name = "lazyqmk"
version = "0.13.3"
edition = "2021"
authors = ["LazyQMK Contributors"]
description = "Interactive terminal workspace for QMK firmware for mechanical keyboards"
license = "MIT"
repository = "https://github.com/Radialarray/LazyQMK"
homepage = "https://github.com/Radialarray/LazyQMK"
readme = "README.md"
keywords = ["keyboard", "qmk", "tui", "terminal", "editor"]
categories = ["command-line-utilities", "text-editors"]

# Disable auto-discovery so we can conditionally include binaries
autobins = false

[[bin]]
name = "lazyqmk"
path = "src/main.rs"

# NOTE: lazyqmk-web binary temporarily commented out for cargo-dist compatibility
# Will be built separately via custom CI workflow in future releases
# [[bin]]
# name = "lazyqmk-web"
# path = "src/bin/lazyqmk-web.rs"
# required-features = ["web"]

[features]
default = ["ratatui", "web"]
ratatui = ["dep:ratatui"]
web = ["dep:axum", "dep:tower-http", "dep:tokio", "dep:tracing", "dep:tracing-subscriber", "dep:sha2", "dep:rust-embed", "dep:mime_guess"]

[dependencies]
ratatui = { version = "0.29", optional = true }
crossterm = "0.29"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
json5 = "1.3"
serde_yml = "0.0.12"
toml = "0.9"
regex = "1.0"
anyhow = "1.0"
clap = { version = "4.5", features = ["derive"] }
dirs = "6.0"
chrono = { version = "0.4", features = ["serde"] }
arboard = "3.6"
dark-light = "1.1"
uuid = { version = "1.19", features = ["v4", "serde"] }
zip = { version = "2.1", default-features = false, features = ["deflate"] }

# Web API dependencies (optional)
axum = { version = "0.8", optional = true }
tower-http = { version = "0.6", features = ["cors", "trace"], optional = true }
tokio = { version = "1", features = ["rt-multi-thread", "macros"], optional = true }
tracing = { version = "0.1", optional = true }
tracing-subscriber = { version = "0.3", features = ["env-filter"], optional = true }
sha2 = { version = "0.10", optional = true }
rust-embed = { version = "8.5", optional = true }
mime_guess = { version = "2.0", optional = true }

[dev-dependencies]
tempfile = "3.0"
# Web API test dependencies (only needed when testing web feature)
tower = { version = "0.5", features = ["util"] }
http-body-util = "0.1"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
strip = true

[profile.dist]
inherits = "release"
lto = "thin"

[profile.dev]
opt-level = 0
debug = true

# Clippy configuration
[lints.clippy]
pedantic = { level = "warn", priority = -1 }
nursery = { level = "warn", priority = -1 }
cargo = { level = "warn", priority = -1 }
# Allow some pedantic lints that are too strict for this project
module_name_repetitions = "allow"
missing_errors_doc = "allow"
missing_panics_doc = "allow"
# Multiple crate versions - caused by transitive dependencies, cannot fix
multiple_crate_versions = "allow"
# if_not_else - sometimes if !cond is clearer
if_not_else = "allow"
# option_if_let_else - sometimes if let is clearer than map_or_else
option_if_let_else = "allow"
# items_after_statements - sometimes defining items near their use is clearer
items_after_statements = "allow"
# branches_sharing_code - sometimes duplicating at end is clearer
branches_sharing_code = "allow"
# doc_markdown - false positives for technical terms
doc_markdown = "allow"
# needless_pass_by_value - sometimes owned types are clearer
needless_pass_by_value = "allow"
# similar_names - false positives for color components (r,g,b)
similar_names = "allow"
# too_many_arguments - some builders need many params
too_many_arguments = "allow"
# match_same_arms - sometimes separate arms are clearer for documentation
match_same_arms = "allow"
# missing_const_for_fn - false positives for functions that may change
missing_const_for_fn = "allow"
# redundant_else - sometimes else after return is clearer
redundant_else = "allow"
# unused_self - may be needed for future implementation
unused_self = "allow"
# unnested_or_patterns - sometimes separate patterns are clearer
unnested_or_patterns = "allow"
# if_same_then_else - intentional for clarity in some cases
if_same_then_else = "allow"
# ptr_arg - PathBuf reference is acceptable in some cases
ptr_arg = "allow"
# must_use_candidate - not all Self returns need must_use
must_use_candidate = "allow"
# or_fun_call - sometimes lazy evaluation isn't needed
or_fun_call = "allow"
# implicit_hasher - HashMap is fine for internal use
implicit_hasher = "allow"
# too_many_lines - some functions are inherently large
too_many_lines = "allow"
# fn_params_excessive_bools - some functions need multiple bool params
fn_params_excessive_bools = "allow"
# single_match_else - sometimes match is clearer than if let
single_match_else = "allow"
# return_self_not_must_use - builders don't need must_use
return_self_not_must_use = "allow"
# option_map_unwrap_or - sometimes unwrap_or_else is fine
map_unwrap_or = "allow"
# useless_let_if_seq - sometimes let before if is clearer
useless_let_if_seq = "allow"
# explicit_iter_loop - for x in &vec is fine
explicit_iter_loop = "allow"
# struct_field_names - field names matching struct name is fine
struct_field_names = "allow"
# wrong_self_convention - to_* with &self is fine for some types
wrong_self_convention = "allow"
# cast_possible_wrap - intentional for terminal coordinates
cast_possible_wrap = "allow"
# str_to_string - String::from vs to_string is a style choice
str_to_string = "allow"
# needless_collect - sometimes collecting is clearer
needless_collect = "allow"
# explicit_deref_methods - .as_ref() vs &* is a style choice
explicit_deref_methods = "allow"
# use_self - Self vs type name is a style choice
use_self = "allow"
# let_else - sometimes if let is clearer
manual_let_else = "allow"
# enum_variant_names - common prefix is intentional in some enums
enum_variant_names = "allow"
# tuple_array_conversions - array.into() is fine
tuple_array_conversions = "allow"
# explicit_counter_loop - enumerate isn't always clearer
explicit_counter_loop = "allow"
# needless_borrow - sometimes & is clearer
needless_borrow = "allow"
# single_match - sometimes match is clearer than if let
single_match = "allow"
# string_replace_chain - consecutive replace is fine
collapsible_str_replace = "allow"
# uninlined_format_args - format!("{}", x) vs format!("{x}") is a style choice
uninlined_format_args = "allow"
# needless_pass_by_ref_mut - sometimes &mut is needed for API consistency
needless_pass_by_ref_mut = "allow"

[lints.rust]
unsafe_code = "forbid"
missing_docs = "warn"
